---
title: "Urban Stream Restoration: building a more resilient urban environmental system"
subtitle: "Group B"
author:
  - name: "Stepan Prikazchikov"
    affiliation: "MSc Geomatics"
  - name: "Roger Marin de Yzaguirre"
    affiliation: "MSc Landscape Architecture"
  - name: "Yaying Hao"
    affiliation: "MSc Urbanism"
  - name: "Jaee A. Naik"
    affiliation: "MSc Urbanism"
format: html
lightbox: TRUE
code-fold: TRUE # collapse code in the HTML output
---

::: callout
## This is a computational notebook

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

Install necessary packages

```{r}
#install.packages("sf") 
#install.packages("dplyr")
#install.packages("leaflet")
#install.packages("RColorBrewer")
#system("echo %JAVA_HOME%", intern = TRUE)
#install.packages("rJava")
#install.packages("swipeR")
#install.packages("ggplot2")
```

Load necessary packages

```{r}
library(sf) # for processing vector data 
library(dplyr) # for selecting and transforming data
library(leaflet)
library(RColorBrewer)
library(rJava)
#library(swipeR) # Could be depreciated, as in I don't want to use it 
library(ggplot2)
library(htmltools)
```
:::

## Introduction

In this course, we explored urban stream restoration in Poznań, Poland, using two primary methodological approaches: Multi-Criteria Decision Analysis (MCDA) and Typology Construction. For each method, we identified relevant objectives and formulated research questions tailored to the respective analytical framework. In the case of MCDA, the selection of criteria and the rationale behind their inclusion will be detailed in the *Methods* section, while the corresponding analytical outcomes will be presented in the *Results* section.

### MCDA

#### GOAL

-   **Urban Stream Restoration**: building a more resilient urban environmental system

#### OBJECTIVES AND RESEARCH QUESTIONS

-   **Enrich Biodiversity**: Which areas have a good base for implementing nature-based restoration solutions that nurture better biodiversity?

-   **Promote Climate Adaptation**: Which areas are most in need of interventions to promote climate adaptation?

-   **Improve Quality of Life**: Which areas are most suitable for neighborhood-oriented interventions that improve the quality of life of local residents?

### Typology Construction

#### GOAL

-   *to be updated*

#### OBJECTIVES AND RESEARCH QUESTIONS

-   *to be updated*

## Roles and Explanations

-   **Stepan: Data analyst**\
    Data analyst and Presentation lead.
-   **Roger: Landscape architect**\
    Landscape expert and Mapping
-   **Yaying: Mapping and Design**\
    Data visualization and Mapping.
-   **Jaee: Research Lead**\
    Oversees background research

## Research Background

**What is the Context of Stream Restoration in Poznan?**

1.  Streams go through multiple land use/typology: ***need to choose the suitable restoration strategy based on specific context*** ![](report_files/libs/imgs/0-1_poznan_satellite_map.jpeg)\
2.  Streams end up in Warta River Valley: ***River Warta included in the research together with the stream system*** ![](report_files/libs/imgs/0-2_topography.jpeg)\

## Methods

*In the Methods section, describe what are the the spatial unit (and the rationale), the indicators you choose and why, the workflow of MCDA, and later the typology construction. (from comment)*

### MCDA

#### MCDA Structure

![](report_files/libs/imgs/1-1_MCDA_structure.jpg)\

***explanation texts***

![](report_files/libs/imgs/1-2.jpg)\

***explanation texts***

#### Grid Division: Why Hexagon Grid and What are the Parameters? ![](report_files/libs/imgs/1-3_full_grid.jpeg)

**Hexagons**:\
- Equal distance to neighboring cells\
- Reduced edge effect\
**Diameter = 500m**:\
- 5-10min walk distance\
- Integrate stream restoration intervention into urban life in the vicinity\
- Reasonable amount of cells in the whole city area\

![](report_files/libs/imgs/1-4_buffer.jpeg)\

**Buffer Zone = 300m**:\
- Potential area under the influence of the streams for local residents\
- Suitable for collecting relevant context information

#### Indicators and Argumentation

1.  **Enrich Biodiversity**\
    1-1. Healthy Vegetation Density\
    1-2. Natural Land Use Density\
    1-3. Species Richness\
    1-4. Nuisance from Industries\

2.  **Promote Climate Adaptation**\

3.  **Improve Quality of Life**\

### Typology construction

#### Chosen Fields

#### K-Means Method

#### Constructing Types

## Results

### MCDA

#### Analysis and Results

1.  **Enrich Biodiversity**\
    1-1. Healthy Vegetation Density\
```{r}
healthy_vegetation <- "files/enrich_biodiversity/vegetation_health_index.gpkg"

hv <- st_read(healthy_vegetation, quiet = TRUE)

# Standardize (scale) values
hv_scaled <- hv |> 
  mutate(hv_scaled = as.numeric(scale(hv$vegetation_health_index_small_grid_ndvi_mean)))
```
    
    ![](report_files/libs/imgs/2-1.jpg)\
    Processing: ***NDVI --\> Threshold \> 0.2 --\> Zonal Statistics --\> Mean --\> Normalization***\
    ![](report_files/libs/imgs/2-2_vegetation_health_index.jpeg)\

    1-2. Natural Land Use Density\
    ![](report_files/libs/imgs/2-3and5_Greenscapes%20base%20map.jpg){width="467"}\
    Processing: ***Landuse Map--\> Assigning All Green a Single Category \> Join Attributes by field value--\> Areas per grid assigned to each grid --\> Normalization***\
    ![](report_files/libs/imgs/2-4_GreensLandusemap.jpg){width="466"}\

    1-3. Species Richness\
    ![](report_files/libs/imgs/2-5_DATA_Species_Richness.jpg)\
    Processing: ***Give biodiversity value --\> Intersect with greed --\> Area Biodiversity Value --\> Add Biodiversity index from same hex --\> Dissolve --\> Join attributes by location***\
    ![](report_files/libs/imgs/2-6_Species_Richness.jpg)\

    1-4. Nuisance from Industries\
    ![](report_files/libs/imgs/2-7_Industries%20base%20map%20.jpg){width="466"}\
    Processing: ***Landuse Map--\> Sort only the industries \> Join Attributes by field value--\> Amount of industries assigned per grid --\> Normalization***\
    (placeholder 2-8)\

    1-5. Nuisance from Hard Borders\
    ![](report_files/libs/imgs/2-9_road_data.jpeg)\
    Processing: ***road data --\> Threshold: maxspeed \>= 40km/h --\> Intersection and Join --\> Sum --\> Normalization***\
    ![](report_files/libs/imgs/2-10_road_index.jpeg)\

    1-6. Historic Stream Waterway\
    (placeholder 2-11)\
    Processing:\
    (placeholder 2-12)\

    1-7. Historic Soil Type\
    (placeholder 2-13)\
    Processing:\
    (placeholder 2-14)\

Measurements Importance Ranking:\

(placeholder 2-15)\

Saaty Matrix:

(placeholder 2-16)

2.  **Promote Climate Adaptation**\
    2-1. Risk of Flooding\
    ```{r}
flood_risk <- "files/promote_climate_adaptation/flood_risk_rp50.gpkg"

fr <- st_read(flood_risk, quiet = TRUE)

# Standardize (scale) values
fr_scaled <- fr |> 
  mutate(fr_scaled = as.numeric(scale(fr$flood_sum)))
```
    ![](report_files/libs/imgs/3-1_flood_data.jpeg)\
    Processing:***flooding depth map --\> subtract permenant waterbody --\> Zonal Statistics --\> Sum --\> Normalization***\
    ![](report_files/libs/imgs/3-2_flood_risk_index.jpeg)\

    2-2. Density of Impermeable Surfaces\
    ```{r}
impermeable_surface <- "files/promote_climate_adaptation/surface_impermeability.gpkg"

is <- st_read(impermeable_surface, quiet = TRUE)

# Standardize (scale) values
is_scaled <- is |> 
  mutate(is_scaled = as.numeric(scale(is$inperm_sum)))
```
    ![](report_files/libs/imgs/3-3_permeability_data.jpeg)\
    Processing:***Landcover --\> Zonal Statistics --\> Sum --\> Normalization***\
    ![](report_files/libs/imgs/3-4_permeability_index.jpeg)\

    2-3. Water system connectivity\ # DELETE THIS? ITS BEEN REPLACED BY NAVIGABILITY OF STREAM NETWORK? 
    (placeholder 3-5)\
    Processing:\
    (placeholder 3-6)\

    2-4. Drought High-Risk Areas\
    (placeholder 3-7)\
    Processing:\
    (placeholder 3-8)\

    2-5 & 6. Heat Risk Index\

    Combining UHI max (as defined by <https://support.tygron.com/wiki/UHI_formula_(Heat_Overlay)> ) with the number of Hot nights (\>22C) observed between 2015 - 24 in the summer months.

```{r}
hot_nights <- "files/promote_climate_adaptation/10y_aggregated_hotnights.gpkg"
UHI_max <- "files/promote_climate_adaptation/UHI_max.gpkg"

hn <- st_read(hot_nights, quiet = TRUE)
uhi <- st_read(UHI_max, quiet = TRUE)

# Standardize (scale) values
hn_scaled <- hn |> 
  mutate(hn_scaled = as.numeric(scale(hn$X10y_hotnights)))

uhi_scaled <- uhi |> 
  mutate(uhi_scaled = as.numeric(scale(uhi$UHI_max_norm)))

#head(hn_scaled)

# Combine by dropping geometry from one
hr_index <- hn_scaled |> 
  select(geom, hn_scaled) |> 
  bind_cols(uhi_scaled |> st_drop_geometry() |> select(uhi_scaled)) |> 
  mutate(heat_risk_index = hn_scaled + uhi_scaled)

hr_scaled <- hr_index |>
  mutate(hr_scaled = as.numeric(scale(hr_index$heat_risk_index)))

### Map plotting
p1 <- ggplot(hn) +
  geom_sf(aes(fill = X10y_hotnights), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "Number of Hot Nights (2015–24)", fill = "Hot Nights") +
  theme_minimal()

p2 <- ggplot(uhi) +
  geom_sf(aes(fill = UHI_max_norm), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "UHI max", fill = "UHI") +
  theme_minimal()

p3 <- ggplot(hn_scaled) +
  geom_sf(aes(fill = hn_scaled), color = NA) +
  scale_fill_gradient2() +
  labs(title = "Standardized Hot Nights", fill = "Z-score") +
  theme_minimal()

p4 <- ggplot(uhi_scaled) +
  geom_sf(aes(fill = uhi_scaled), color = NA) +
  scale_fill_gradient2() +
  labs(title = "Standardized UHI max", fill = "Z-score") +
  theme_minimal()

p5 <- ggplot(hr_index) +
  geom_sf(aes(fill = heat_risk_index), color = NA) +
  scale_fill_gradient2() +
  labs(title = "Combined Heat Risk Index", fill = "Risk Index") +
  theme_minimal()

print(p1)
print(p2)
print(p3)
print(p4)
print(p5)

# Write the combined file (Comment out if it has been done once)
#st_write(hr_index, "files/promote_climate_adaptation/heat_risk.gpkg")

```

```{r}
# Read the combined result
hr_index <- st_read("files/promote_climate_adaptation/heat_risk.gpkg", quiet = TRUE)

# Reproject to WGS 84 for leaflet
hr_index_wgs84 <- st_transform(hr_index, crs = 4326)

pal <- colorNumeric(
  palette = "RdBu", 
  domain = hr_index_wgs84$heat_risk_index,
  reverse = TRUE,
  na.color = "transparent"
)

bbox <- st_bbox(hr_index_wgs84)

leaflet(data = hr_index_wgs84) %>%
  addProviderTiles(
    providers$Esri.WorldImagery,
    options = providerTileOptions(opacity = 0.5)
  ) %>%
  addPolygons(
    fillColor = ~pal(heat_risk_index),
    color = "#444444",
    weight = 0.5,
    opacity = 1,
    fillOpacity = 0.3,
    highlightOptions = highlightOptions(
      weight = 2,
      color = "#666",
      fillOpacity = 0.9,
      bringToFront = TRUE
    ),
    label = ~paste("Heat Risk Index:", round(heat_risk_index, 2))
  ) %>%
  addLegend(
    pal = pal,
    values = ~heat_risk_index,
    title = "Heat Risk Index",
    position = "bottomright"
  ) 

```

    2-7. Terrain slope\
```{r}
terrain_slope <- "files/promote_climate_adaptation/terrain_slope.gpkg"

ts <- st_read(terrain_slope, quiet = TRUE)

ts_scaled <- ts |> 
  mutate(ts_scaled = as.numeric(scale(ts$slope_mean)))

p6 <- ggplot(ts_scaled) +
  geom_sf(aes(fill = ts_scaled), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "Mean slope angle", fill = "Std slope") +
  theme_minimal()

print(p6)

```

      
    2-8. River sinuosity\  
```{r}
river_sinuosity <- "files/promote_climate_adaptation/river_sinuosity.gpkg"

rs <- st_read(river_sinuosity, quiet = TRUE)

rs_scaled <- rs |> 
  mutate(rs_scaled = as.numeric(scale(rs$wm_sinuosity)))

p7 <- ggplot(rs_scaled) +
  geom_sf(aes(fill = rs_scaled), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "River sinuosity", fill = "Sinuosity") +
  theme_minimal()

print(p7)

```



Measurements Importance Ranking:\

(placeholder 3-13)\

Saaty Matrix:

(placeholder 3-14)

3.  **Improve Quality of Life**\
    3-1. Population living in the Vicinity\
    ![](report_files/libs/imgs/4-1_population_data.jpeg)\
    Processing:***population data --\> Zonal Statistics --\> Sum --\> Normalization***\
    ![](report_files/libs/imgs/4-2_population_index.jpeg)\

    3-2. Urbanized Land Use Density\
    ![](report_files/libs/imgs/4-3_Landusemap_basemap.jpg){width="463"}\
    Processing: ***Landuse Map--\> Assigning Broader Categories ('residential', 'commercial', 'industrial', 'greens') \> Join Attributes by field value--\> Sum of Areas per Landuse assigned to each grid--\> Normalization***\
    ![](report_files/libs/imgs/4-4_Landusemap_urbanisation.jpg){width="462"}\

    3-3. Density of Attractions for People\
    ![](report_files/libs/imgs/4-5_poi_data.jpeg)\
    Processing:***point of interest data --\> Count Points in Polygon --\> Normalization***\
    ![](report_files/libs/imgs/4-6_poi_index.jpeg)\

    3-4. Navigability of Stream Network\
```{r}
stream_navigability <- "files/improve_quality_of_life/navigability_indicator.gpkg"

sn <- st_read(stream_navigability, quiet = TRUE)

# Standardize (scale) values
sn_scaled <- sn |> 
  mutate(sn_scaled = as.numeric(scale(sn$navigability_indicator)))

head(sn_scaled)

p8 <- ggplot(sn_scaled) +
  geom_sf(aes(fill = sn_scaled), color = NA) +
  scale_fill_gradient2() +
  labs(title = "Navigability of streams", fill = "Standard devation of roads within 100m") +
  theme_minimal()

print(p8)
```
    Processing:***100m buffer around waterways --\> intersect buffer with roads --\> split roads every 10m --\> count road segments in Polygon --\> Normalization***\
    (placeholder 4-8)\

    3-5. Local Centrality Index\
    ![](report_files/libs/imgs/4-9_local_centrality_data.jpeg)\
    Processing:***Angular Integration (500M) --\> Intersection --\> join value by location (Group stats) --\> Mean --\> Normalization***\
    ![](report_files/libs/imgs/4-10_local_centrality_index.jpeg)\

    3-6. Public Transport Accessibility\
    ![](report_files/libs/imgs/4-11_public_transport_data.jpeg)\
    Processing:***public transport station data --\> Count Points in Polygon --\> Normalization***\
    ![](report_files/libs/imgs/4-12_public_transport_index.jpeg)\

    3-7. Angular Betweeness Index\
    (placeholder 4-13)\
    Processing:\
    (placeholder 4-14)\

    3-8. Density Indicators (FSI/GSI/ORS) Developed from N-DSM. To create N-DSM, DSM - DEM, verify results filter out inconsistent height values. Calculate floorspace sum: calculate assumed number of floors by performing height / 3 (assumed that each floor is 3m), floorspace = area of polygon \* number of floors. Calculate footpring by calculating the area of the polygon. Perform spatial join, calculating the sum of both floorspace and footprint. Perform FSI, GSI, and OSR post processing in R as follows:

```{r}
density_indicator <- "files/improve_quality_of_life/DensityIndicators_raw.gpkg"

di <- st_read(density_indicator, quiet = TRUE)

di_result <- di |>
  mutate(
    FSI = ifelse(is.finite(floorspace_sum / area), floorspace_sum / area, 0),
    GSI = ifelse(is.finite(footprint_sum / area), footprint_sum / area, 0),
    OSR = ifelse(FSI != 0 & !is.na(FSI), (1 - GSI) / FSI, 0)
  )

osr_scaled <- di_result |> 
  mutate(osr_scaled = as.numeric(scale(di_result$OSR)))

#Write Density Indicator results to file KEEP COMMENTED OUTx
#st_write(di_result, "files/improve_quality_of_life/density_indicators.gpkg")

p9 <- ggplot(di_result) +
  geom_sf(aes(fill = OSR), color = NA) +
  scale_fill_viridis_c() +
  labs(title = "Open Space Ratio", fill = "OSR") +
  theme_minimal()

print(p9)

# Add quantile bins (3x3 grid = 9 color categories)
di_bivar <- di_result |>
  mutate(
    FSI_q = ntile(FSI, 3),
    GSI_q = ntile(GSI, 3),
    bivar_class = paste0(FSI_q, "-", GSI_q)
  )

bivar_palette <- c(
  "1-1" = "#e8e8e8",  
  "1-2" = "#b5c0da",
  "1-3" = "#6c83b5",
  "2-1" = "#b8d6be",
  "2-2" = "#90b2b3",
  "2-3" = "#567994",
  "3-1" = "#73ae80",
  "3-2" = "#5a9178",
  "3-3" = "#2a5a5b"   
)

### Experimental BIVARIATE CHOROPLETH MAP 
p10 <- ggplot(di_bivar) +
    geom_sf(aes(fill = bivar_class), color = NA) +
    scale_fill_manual(values = bivar_palette) +
    labs(
      title = "Bivariate Choropleth: FSI vs GSI",
      fill = "FSI (x) / GSI (y)"
    ) +
    theme_minimal()

print(p10)
```

    3-9. Attraction betweenness\
    ```{r}
attraction_betweenness <- "files/improve_quality_of_life/attraction_betweeness.gpkg"

ab <- st_read(attraction_betweenness, quiet = TRUE)

# Replace NA with 0 before scaling
ab_cleaned <- ab |> 
  mutate(abt_cell_data_mean = ifelse(is.na(abt_cell_data_mean), 0, abt_cell_data_mean))

# Standardize and ensure result is numeric with no NAs
ab_scaled <- ab_cleaned |> 
  mutate(ab_scaled = as.numeric(scale(abt_cell_data_mean)),
         ab_scaled = ifelse(is.na(ab_scaled), 0, ab_scaled))
```    
    (placeholder 4-17)\
    Processing:\
    (placeholder 4-18)\
    
Measurements Importance Ranking:\

(placeholder 4-15)\

Saaty Matrix:

(placeholder 4-16)

#### Aggregated Results for Research Questions

1.  **Which areas have a good base for implementing nature-based restoration solutions that nurture better biodiversity?**\
    (placeholder image5-1)\

2.  **Which areas are most in need of interventions to promote climate adaptation?**\
    (placeholder image5-2)\

3.  **Which areas are most suitable for neighborhood-oriented interventions that improve the quality of life of local residents?**\
    ![](report_files/libs/imgs/5-3_rq3_index.jpeg)\
    ***When the area has higher index, it means: (relatively)***\
    -*More people live in this area*\
    -*The area is close to existing settlement center*\
    -*The area has good public transport accessibility*\
    -*Landuse in this area allow community-oriented intervention*\
    -*Already some attractions for people are in this area*

### Typology Construction

Typology construction based on an 'Requirements by Priority': Must-have, Should-have, Could-have, and wish list (Necessary for the product to perform its basic functions, Expand the software's functionality, but aren't integral to its operation, Less important, but can serve as nice additions to the app's feature list, Potentially innovative additions that are usually unrelated to the core objective of the product). 

We can assume that the typology creation will create at least 3 - 5 different clusters. We can assume that one cluster must meet all of our (positive) criteria, as some areas within a cities boundaries will have to anyway be taken as an ideal to work towards. A second cluster would show an area in dire need of change, with a high possibility thereof. A third would similarly need change, but would be less likely a contender.

Our typology creation thus follows two narratives: Which locations are in need of intervention, and Which locations are ready for intervention. By answering these questions, we will be able to fill in the 'requirements by priority' school of thought and develop a targeted approach for 

**Variables**\ 
Discussed variables: 
Channel morphology
  Sinuosity
  Floodplain width
  Open water surface
Land use cover
  Impervious
  Vegetation
Landscape 
  Green space connectivity
Mobility
  Slow mobility accessibility
Building morphology
  Floor area ratio
  
Our variables: 
  RISK ATTRRIBUTES
  Heat_risk (aggregated hot nights and UHI max)
  flood_risk_rp50
  surface_impermeability
  vegetation_health_index
  
  BENEFIT ATTRIBUTES:
  terrain_slope
  density_indicators (any can be used, OSR as most logical?)
  attraction_betweenness 
  navigability_indicator 

```{r}
# Create Clustering input from previous datasets. 
geometry <- st_geometry(hr_scaled)

# Combine all scaled variables into one data frame
cluster_attributes <- data.frame(
  hr_scaled = hr_scaled$hr_scaled,
  fr_scaled = fr_scaled$fr_scaled,
  is_scaled = is_scaled$is_scaled,
  hv_scaled = hv_scaled$hv_scaled,
  ts_scaled = ts_scaled$ts_scaled,
  osr_scaled = osr_scaled$osr_scaled,
  ab_scaled = ab_scaled$ab_scaled,
  sn_scaled = sn_scaled$sn_scaled
)

# Combine geometry and attributes into one sf object
cluster_input <- st_sf(cluster_attributes, geometry = geometry)
#head(cluster_input)
#st_write(cluster_input, "files/cluster_analysis/clusters_raw.gpkg")  

inertia <- numeric()

# Try k values from 2 to 9
k_values <- 2:9

# Loop through each k value
for (k in k_values) {
  km <- kmeans(cluster_attributes, centers = k, nstart = 100) 
  
   #tot.withinss is Total within-cluster sum of squares
   #This measures how compact the clusters are: lower is better.
  inertia <- c(inertia, km$tot.withinss)
}

# Combine the results into a data frame for plotting
elbow_df <- data.frame(k = k_values, inertia = inertia)

print(elbow_df)

# Make the elbow plot
plot(k_values, inertia,
     type = "b",                  # shown both points + lines 
     col = "darkblue",
     main = "Elbow Method")

# `set.seed()` sets the random number generator to a fixed state
# Set the seed so the clustering result is always the same when re-run
set.seed(0)  # The number 0 is just a fixed choice. You can also use 10, 345, etc.

# Choose the number of clusters based on the elbow plot
k <- 5

# Run K-means clustering on the standardized data
kmeans_result <- kmeans(cluster_attributes, centers = k, nstart = 20)

# Add the cluster labels to the spatial data
cluster_input$cluster <- as.factor(kmeans_result$cluster) # The result kmeans_result$cluster is a list of cluster labels (1 to 4), in the same order as the original rows in X_scaled and grids

head(cluster_input)

# Show how many grids fall into each cluster
print(table(cluster_input$cluster))

# Plot clusters with base R
plot(cluster_input["cluster"], 
     main = "Spatial Pattern of Urban Stream Clusters", 
     border = NA)
```


## Discussion

## Conclusion
